# -*- coding: utf-8 -*-
"""proyecto-divorcios.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qvXzU3PFoj7cqsk5tLFfa-sU0Vj1C_we
"""

from google.colab import files
import pandas as pd
import matplotlib.pyplot as plt

#
df2020 = pd.read_csv("inec_divorcios_2020.csv", sep=';')
# df2021 = pd.read_csv("inec_divorcios_2021.csv", sep=';', on_bad_lines='skip', encoding='latin-1')
# df2022 = pd.read_csv("inec_divorcios_2022.csv", sep=';')
# df2023 = pd.read_csv("inec_divorcios_2023.csv", sep=';')

#Eliminar datos atípicos de fechas (fecha de 9999/99/99)
columnas_anios = ['anio_insc', 'anio_div', 'anio_mat', 'anio_nac1', 'anio_nac2']
columnas_meses = ['mes_insc', 'mes_div', 'mes_mat', 'mes_nac1', 'mes_nac2']
columnas_dias = ['dia_insc', 'dia_div', 'dia_mat', 'dia_nac1', 'dia_nac2']
meses_map = {
    "Enero": 1, "Febrero": 2, "Marzo": 3, "Abril": 4, "Mayo": 5, "Junio": 6,
    "Julio": 7, "Agosto": 8, "Septiembre": 9, "Octubre": 10, "Noviembre": 11, "Diciembre": 12
}
df2020['mes_insc'] = df2020['mes_insc'].map(meses_map)
df2020['mes_div'] = df2020['mes_div'].map(meses_map)
df2020['mes_mat'] = df2020['mes_mat'].map(meses_map)
df2020['mes_nac1'] = df2020['mes_nac1'].map(meses_map)
df2020['mes_nac2'] = df2020['mes_nac2'].map(meses_map)

filtro = (df2020[columnas_anios] > 2024).any(axis=1) | (df2020[columnas_anios] < 1900).any(axis=1)
df2020 = df2020.drop(df2020[filtro].index)

filtro2 = (df2020[columnas_meses] > 12).any(axis=1) | (df2020[columnas_meses] < 1).any(axis=1)
df2020 = df2020.drop(df2020[filtro2].index)

filtro3 = (df2020[columnas_dias] > 31).any(axis=1) | (df2020[columnas_dias] < 1).any(axis=1)
df2020 = df2020.drop(df2020[filtro3].index)

#Convertir formato fecha
df2020['fecha_insc'] = pd.to_datetime(df2020['fecha_insc'], format='%Y/%m/%d')
df2020['fecha_div'] = pd.to_datetime(df2020['fecha_div'], format='%Y/%m/%d')
df2020['fecha_mat'] = pd.to_datetime(df2020['fecha_mat'], format='%Y/%m/%d')
df2020['fecha_nac1'] = pd.to_datetime(df2020['fecha_nac1'], format='%Y/%m/%d')
df2020['fecha_nac2'] = pd.to_datetime(df2020['fecha_nac2'], format='%Y/%m/%d')
df2020 = df2020.drop(columnas_anios, axis=1)
df2020 = df2020.drop(columnas_meses, axis=1)
df2020 = df2020.drop(columnas_dias, axis=1)
# print("Valores Null ->", df2020.isnull().sum().sum())
# print("Valores Vacios ->",(df2020 == "").sum().sum())
# print(df2020.info())

#Eliminar datos atípicos de edades (edad de 9999/99/99)
# print(df2020['edad_1'].describe())
# print(df2020['edad_1'].describe())
# print(df2020['hijos_1'].describe())
# print(df2020['hijos_2'].describe())

columnas_hijos = ['hijos_1', 'hijos_2']
filtro_hijos = (df2020[columnas_hijos] > 20).any(axis=1) | (df2020[columnas_hijos] < 0).any(axis=1)
df2020 = df2020.drop(df2020[filtro_hijos].index)

#Eliminar variables innecesarias
columnas_innesc = ['cant_insc', 'parr_insc', 'cant_hab1', 'parr_hab1', 'cant_hab2', 'parr_hab2']
df2020 = df2020.drop(columnas_innesc, axis=1)

#Revisar Balanceo de Variable Objetivo
# df2020['prov_insc'].value_counts(normalize=True)  # Proporción por clase

# Diccionario de regiones a provincias
region_a_provincias = {
    'Sierra': ['Chimborazo', 'Pichincha', 'Azuay', 'Loja', 'Tungurahua',
               'Cañar', 'Cotopaxi', 'Imbabura', 'Carchi', 'Bolívar'],
    'Costa': ['Manabí', 'Guayas', 'El Oro', 'Santa Elena',
              'Santo Domingo de los Tsáchilas', 'Esmeraldas', 'Los Ríos'],
    'Oriente': ['Sucumbíos', 'Zamora Chinchipe', 'Orellana', 'Napo',
                'Morona Santiago', 'Pastaza'],
    'Galápagos': ['Galápagos']
}

# Función para mapear región a provincias
def region_a_provincia(provincia):
    for region, provincias in region_a_provincias.items():
        if provincia in provincias:
            return region
    return None  # Si no se encuentra, devolver None (opcional)

# Aplicar la función a la columna
df2020['prov_insc'] = df2020['prov_insc'].apply(region_a_provincia)


mapear_causas_div = {
    'Mutuo consentimiento': ['Por mutuo consentimiento vía judicial', 'Por mutuo consentimiento vía notarial'],
    'Abandono': ['El abandono injustificado de cualquiera de los cónyuges por más de seis meses ininterrumpidos'],
    'Otro': ['Sin Información'],
    'Falta de armonía': ['El estado habitual de falta de armonía de las dos voluntades en la vida matrimonial'],
    'Violencia': ['Los tratos crueles o violencia contra la mujer o miembros del núcleo familiar', 'Las Amenazas graves de un cónyuge contra la vida del otro', 'La tentativa de uno de los cónyuges contra la vida del otro'],
    'Actividades ilícitas': ['La condena ejecutoriada a pena privativa de la libertad mayor a diez años', ],
    'Adulterio': ['El adulterio de uno de los cónyuges', 'Los actos ejecutados por uno de los cónyuges con el fin de involucrar al otro o a los hijos en actividades ilícitas'],
    'Uso de sustancias/Alcohol': ['El que uno de los cónyuges sea ebrio consuetudinario o toxicómano']
}

# Función para mapear
def mapear_causas(causa_anterior):
    for causa_nueva, causas in mapear_causas_div.items():
        if causa_anterior in causas:
            return causa_nueva
    return causa_anterior  # Si no se encuentra, devolver None (opcional)

# Aplicar la función a la columna
df2020['cau_div'] = df2020['cau_div'].apply(mapear_causas)


continentes_a_paises = {
    "América del Sur": ['Ecuador', 'Colombia', 'Perú', 'Venezuela (República Bolivariana de)', 'Chile', 'Argentina', 'Brasil', 'Uruguay', 'Paraguay'],
    "América del Norte": ['Estados Unidos de América', 'México', 'Canadá', 'Puerto Rico'],
    "América Central y Caribe": ['Cuba', 'República Dominicana', 'Costa Rica', 'Haití', 'El Salvador', 'Panamá', 'América Central y Caribe'],
    "Europa": ['España', 'Alemania', 'Reino Unido', 'Italia', 'Francia', 'Austria', 'Suecia', 'Bélgica', 'Países Bajos', 'Albania', 'Turquía',
               'Ucrania', 'Rumania', 'Finlandia', 'Suiza'],
    "Asia": ['China', 'Iraq', 'Pakistán', 'Irán (República Islámica del)', 'India', 'Israel', 'República Árabe Siria'],
    "Oceanía": ['Australia'],
    "Zonas sin especificar": ['Zonas sin especificar', 'Sin especificar'],
    "Europa y Asia (región transcontinental)": ['Federación de Rusia']
}


# Función para mapear
def mapear_paises(causa_anterior):
    for causa_nueva, causas in continentes_a_paises.items():
        if causa_anterior in causas:
            return causa_nueva
    return causa_anterior  # Si no se encuentra, devolver None (opcional)

# Aplicar la función a la columna
df2020['cod_pais1'] = df2020['cod_pais1'].apply(mapear_paises)
df2020['cod_pais2'] = df2020['cod_pais2'].apply(mapear_paises)


razas_a_etnias = {
    "Afrodescendiente": ['Negra', 'Afroecuatoriana /afrodescendiente'],
    "Otro": ['Otro', 'Sin Información']
}


# Función para mapear
def mapear_etnias(causa_anterior):
    for causa_nueva, causas in razas_a_etnias.items():
        if causa_anterior in causas:
            return causa_nueva
    return causa_anterior  # Si no se encuentra, devolver None (opcional)

# Aplicar la función a la columna
df2020['p_etnica1'] = df2020['p_etnica1'].apply(mapear_etnias)
df2020['p_etnica2'] = df2020['p_etnica2'].apply(mapear_etnias)


niveles_educativos = {
    "Educación Básica": [
        " Primaria",
        " Educación básica",
        " Jardín de Infantes",
        " Centro de alfabetización"
    ],
    "Educación Media": [
        " Secundaria",
        " Educación media / Bachillerato"
    ],
    "Educación Superior": [
        " Superior no Universitario",
        " Superior Universitario",
        " Posgrado"
    ],
    "Sin Información": [
        " Sin información",
        " Ninguno"
    ]
}

# Función para mapear
def mapear_edu(causa_anterior):
    for causa_nueva, causas in niveles_educativos.items():
        if causa_anterior in causas:
            return causa_nueva
    return causa_anterior  # Si no se encuentra, devolver None (opcional)

# Aplicar la función a la columna
df2020['niv_inst1'] = df2020['niv_inst1'].apply(mapear_edu)
df2020['niv_inst2'] = df2020['niv_inst2'].apply(mapear_edu)

df2020.columns

# Crear un histograma para una columna categórica
column_name = 'sabe_leer1'  # Cambiar por el nombre de la columna
df2020[column_name].value_counts().plot(
    kind='bar',
    color='skyblue',
    figsize=(10, 6),
    title=f'Distribución de valores en {column_name}'
)

# Añadir etiquetas
plt.xlabel('Categorías')
plt.ylabel('Frecuencia')
plt.xticks(rotation=45)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

df2020.tail()